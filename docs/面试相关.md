#### 从业经历

##### 工作内容

##### 工作职责

##### 工作成果

回顾自己三年内的工作中，自己都干了那些比较重大且有意义的项目，以及在项目方案上的成果和经验，如何解决开发中所面临的技术问题等等

+ 场景类消息投递（常规/高峰）
+ 会员一体化接口（基于图模式执行）
+ 携程房源接入
+ 分销房源点评回流
+ 折叠点评需求
+ 产品库存系统重构（切面重构，遇见的事务问题）
+ PMS登录（采用配置化的方式，无需代码变动）
+ 接口共享限流问题
+ 高峰运营的任务分发模型
+ 会员中心查询后台（web）
+ 产品中心后台（web）
+ 预热方案（spring结合，泛型化方法方案的支持）

#### Java面试可能遇见的那个它

##### Java核心技术

+ 一个空对象多大内存？
  > 在hotspot虚拟的实现里一个对象对应内存布局采用OOP结构，主要有三个部分：对象头、实例数据、对齐填充。而对象头又包括三部分：对象头（MarkWord）、类（元数据）指针、数组长度！
  > + 对象头：用于存储对象运行时的数据，好比 HashCode、锁状态标志、GC分代年龄等，在64位操作系统中占用 __8个字节__，32位中占用 __4个字节__
  > + 指针：用来指向当前实例所归属的类实例指针，这里会涉及对指针的压缩处理，在开启指针压缩的状况下占 __4个字节__，未开启状况下占 __8个字节__
  > + 数组长度：这部分只有是数组对象才有，这部分占 __4个字节__
  >
  > 所谓的对齐填充，就是Java 对象的大小默认都是按照 __8个字节__ 对齐，也就是说Java对象的大小必须是 __8个字节__ 的倍数。若是算到最后不够 __8个字节__ 的话，那么就会进行对齐填充！
  > 为啥非要进行 __8个字节__ 填充处理？看起来是对空间的一种浪费！这么做的原因是由于 CPU 进行内存访问时，一次寻址的指针大小是 __8个字节__，正好也是 L1 缓存行的大小。
  > 如果不进行内存对齐，则可能出现跨缓存行的情况，进而造成`缓存行污染`。 所以很容易就能算出来一个空对象所占用的内存大小正好就是 __16个字节__。


+ 为什么需要包装类型？int与Integer的区别？
  > + __原因：__
      因为Java本身就是一门面向对象的语言，对象是Java的基础操作单元。很多时候传递数据也需要对象类型，比如`ArrayList`、
      `HashMap`这些集合，只能存储对象类型，因此封装类型存在的意义就很大。封装类型还有很多好处，比如安全性较好，
      可以避免外部操作随意修改成员变量的值，保证了成员变量和数据传递的安全性！
  > + __区别：__
  >  + Integer的初始值是`null`，int的初始值是0;
  >  + Integer存储在堆内存中，int直接存储在栈空间；
  >  + Integer是对象类型，它封装了很多方法和属性。

+ “==” 和 “equals()” 有什么区别，为什么重写“equals()”时也要重写“hashcode()”方法？
  > 首先这两个比较操作存在着本质上的区别，“==” 判断的时引用地址（内存地址）的一致性，但是 “equals” 更偏向于判断对象的数据信息一致性，
  > 而且 “equals” 方法的第一行代码优先采用 “==” 作为判断！有些时候我们会重写 “equals” 方法来个性化判断对象是否相等，在这个重写的过程中，
  > 我们都知道也需要重写 “hashcode” 方法，可是为什么呢？原因是 `hashcode` 会被用来在集合类中查找定位元素，
  > 然而在jdk中默认通过随机数算法来生成 `hashcode`，势必会导致两个不同的对象可能会存在相同的 `hashcode`。
  > 假如仅重写了 “equals“ 而不重写 “hashcode“ 方法，就会造成集合类在存储和查找元素时，完全相同的对象因为 `hashcode` 被存储在了两个不同位置。
  > 这与事实是相违背的，所以提倡 “equals“ 与 ”hashcode“ 一起进行重写，这里也可以得到一个结论：两个完全相同的对象，它们的 `hashcode` 一定相同！

+ 关于HashMap如何解决hash冲突、如何进行内存扩容，底层数据结构的优缺点问题？
  > 

+ ConcurrentHashMap实现原理，它与HashMap有啥区别和不同？
+ ArrayList是如何实现自动扩容的？
+ CopyOnWriteArrayList是如何实现的，与ArrayList的区别？
+ AtomicInteger高并发下的性能问题？
  > 因为多线程同时进行数据修改，底层通过unsafe的CAS机制实现，会造成频繁的空循环问题，使用不当会造成cpu飙升！
  > 可以考虑通过`LongAddr`来避免，在`LongAddr`内部维护了一个数组，当出现并发操作进行多次修改后，
  > 会为每个线程分配一个单独的`AtomicLong`进行修改操作，避免了多个线程操作同一个值造成的性能问题（空循环）！

+ ThreadLocal的使用及原理，内存泄露的原因？
+ ThreadPoolExecutor的执行过程及原理？
+ 为什么不建议通过Executors创建线程池，如何定制线程池参数？
+ ForkJoinPool如何工作的，特点是啥？
+ ThreadPoolExecutor和ForkJoinPool的区别是啥，为什么要设计他们？
+ 同步队列有几种？各有什么特点，使用场景有那些？
+ 你是如何看待指令重排序问题的？
+ Lock的使用问题？
+ 为什么会出现AQS，AQS的实现机制是怎样的，通过它可以干什么？
  > AQS是一种用于多线程队列同步器，JUC包中很多同步组件类都基于AQS进行实现。

+ 什么条件下会产生死锁，如何避免死锁？
+ Synchronize如何实现的，它和Lock的区别是什么？

  > Synchronize是通过jvm指令进行实现的，处于Synchronize中的代码块，在进行字节码转换的时会在代码块执行前后
  > 加入`monitorenter`，`monitorexit`指令。

+ 使用过JUC包下的那些类，工作中用它都做了什么？
+ 你怎么看待lambda表达式，JDK内部如何是如何进行实现的？
+ 实现动态代理的几种方式，如何看待动态代理？

  > 在java中实现动态代理有两种方式：1）JDK的动态代理，通过接口进行代理。2）javassist动态代理，通过继承的方式进行代理，
  > 无法实现`final`类的代理。动态代理的目的是实现类的增强机制，让我们可以在使用类之前对其增强发挥更加强大的作用。

+ Java中的IO类型有那些？NIO又是如何进行实现的？
+ lombok是如何工作的？
  > lombok 在开发中可以帮我简化 setter、 getter 方法生成，日志类的注入、toString 方法的生成都可以通过它提供的注解完成，简化了代码结构！
  > 这些特性和能力都是通过实现 java 中的注解处理器 `javax.annotation.processing.AbstractProcessor`，对类字节码或源文件进行增强处理！

+ 零拷贝是什么？如何实现它？

##### JVM调优技术

##### 数据库技术

+ sql的执行过程及步骤？
+ mysql中的BufferPool机制？
+ mysql支持的索引类型有哪些？它们各自有什么特点
+ B树和B+树？
+ 索引类型有哪些，如何建立索引？
+ mysql的锁类型及特点和场景？
+ mysql的MVCC机制原理？
+ 执行计划（explain）的内容都有什么？
+ 为什么需要进行分库分表？工作中如何实现分库分表？
+ 优化数据查询的方式有那些？
  > 对SQL的优化的方式有很多中，优化需要结合索引结构、数据结构、业务能力等多个方面而进行，否则我们的优化毫无意义！优化的方式有：
  > + 加索引：mysql表的索引不是越多越好，能够满足自身业务需求就好，不要盲目的去加索引
  > + 联合索引：当我们的业务场景中会使用到多个查询条件的时候，我们可以考虑对查询的多个条件建立联合索引
  > + 减少不必要字段的输出：编写 sql 查询语句时，一定要保持一个用什么查什么的习惯，切记一股脑的将所有字段列查询出来。这么做会占用数据库实例的带宽，数据IO的时长也增加
  > + 禁令子查询：如果执行的 sql 存在子查询，那么执行时会建立一张临时表用于存储子查询的结果集，对于临时表的创建都会是一种性能上的消耗，查询的效率大大降低。
  > 优化方式有：1）拆分成两次独立查询，并结合 in 关键字进行优化；2）将子查询降级为 join 联合查询，但是并不建议这么做！
  > 
  > + 分库分表：当我们的数据量是千万级、亿级的话，单表查询就无法快速索引数据（毫秒级别），因为mysql采用了B+树的索引方式，当树的级别超过 3 层就会存在性能。
  > 一般建议单数据表记录数应该不超过 400w 左右，否则就应该采用分库分表的方式来优化数据存储。

+ 事务的隔离级别有哪些？
  > 事务隔离发生在两个或两个以上的事务针对统一数据资源进行访问操作，为了保证单个事务操作的正确性而提出来的一种隔离机制！
  > 进而提出了读未提交、读已提交、可重复读、串行化这四种事务隔离级别。下面针对各个级别的特点和所产生的问题进行详细介绍：
  > + 读未提交：
  > + 读已提交：
  > + 可重复度：
  > + 串行化：

+ mysql中的锁有那些？
  > + 表锁：锁定当前锁所操作的数据表
  > + 行锁：会锁定当前所操作的记录
  > + 间隙锁：锁定一个左开右开的区间，不包含当前记录行
  > + 临建锁：是行锁与表锁的组合，锁定一个左开右闭的区间，包含了当前锁操作的记录行

##### 缓存技术

+ 为什么需要缓存？ 
  > 为了实现高性能、高并发、打造时延性更低的应用程序，通过引入缓存可以很好地解决这个问题。
  > 当程序中某些数据做查询时花费的时间很长（200ms+），但数据又不怎么变化的情况下，引入缓存是充分非必要的手段。
  > 而且缓存对于那些读远远高于写的业务场景来说简直就是一剂良。其实我们所接触的很多技术都有涉及对缓存的运用，
  > 例如：CPU的三级缓存、MySQL的buffer_pool机制，spring中使用到的三级缓存技术等等，都是为了更快地响应和处理数据而选择的技术方案。

+ 使用缓存会带来什么问题？
  > 虽然缓存能够提供更好的性能，我们任何事物都具有双面性，对于缓存而言也不列外。它的好也决定了在运用它的时候也会出现各种问题，常见的问题主要有：
  > + 缓存和数据库双写不一致
  > + 缓存雪崩、缓存穿透、缓存击穿
  > + 缓存并发竞争

+ 缓存雪崩、缓存穿透、缓存击穿分别指什么？如何进行避免呢？
  > 这三个问题在缓存使用场景中会常常被提到，接下来就针对这三个问题的场景及解决方案进行分讨论，首先看看产生这些问题的场景怎样的：
  > + 缓存雪崩：整个缓存系统处于挂掉完全不可用状态，导致所有数据查询都不走缓存，而直接访问数据库的一种现象。
  > + 缓存穿透：业务在进行数据查询时，查询了一个压根就不存在的数据无法命中缓存，每次都需要访问数据库的场景。
  > + 缓存击穿：缓存中的某个热点key在某一时刻过期，后续对于这个key的高并发访问直接请求数据库，就像是在缓存的屏障开凿了一个洞一样。
  > 
  > 针对产生这些问题的现象和场景，我们应该从中找到突破口进行修复或者避免该问题的发生，从而提高缓存的安全性和可靠性。避免的手段与解决方案如下：
  > + 缓存雪崩：1）
  > + 缓存穿透：1）
  > + 缓存击穿：1）

+ redis有哪些基本数据类型？
  > 主要有5大基本数据类型：字符串（String）、列表（list）、哈希表（hash）、无需集合（set）、有序集合（zset）。其次还有三个扩展类型分别是：
  > + 字符串：
  > + 列表：
  > + 哈希表：
  > + 无需集合：
  > + 有序集合：

+ redis的线程模型是怎样的？如何支持高并发，速度又为何快？
  > + 模型：redis 内部使用文件事件处理器并采用了单线程的方式进行实现，因此也叫做单线程模型。需要注意的是在 6.0 版本以后开始采用多线程模型，
  > 这里的多线程模型仅用来处理网络数据的读写和协议的解析（为了利用 IO 期间的 CPU 资源），redis 命令的执行方式依然采用单线程
  > （因为多线程反而会更加复杂，需要去控制key、 Lua、事务、LPUSH/LPOP所产生的并发问题）。
  > + 高并发和快的原因：redis 选择基于 epoll 的 IO 多路复用的方式实现非阻塞 IO 。数据的操作均在内存中完成（内存的处理速度众所周知的快！）， 
  > 选择简单的单线程方式进行数据操作，避免了多线程环境下的上下文切换和锁竞争。采用了 C 语言进行开发实现，而 C 语言程序对于系统而言执行起来更加高效！

+ Redis和Memcached有啥区别？
  > + 数据结构：redis 拥有更多的数据接口，同时也提供更加丰富的数据操作，当我们需要进行复杂数据结构操作的时候 redis 是不错的选择！
  > + 集群能力：redis 在 3.x 版本之后，就能够支持 cluster 模式，然而 memcached 没有原生的集群模式，依赖客户端实现对集群中分片数据的写入操作。
  > + 性能优势：在进行数据存储时，redis 采用单核，而 memcached 采用多核。平均到每一个核上 redis 在存储小数据处时对 memcached 性能更高，
  > 而在 100k 以上的数据中，Memcached 性能要高于 Redis！

+ 跳跃表是一种怎样的数据结构？
  > todo:

##### tomcat技术

+ 如何实现Servlet？
+ 如何看待jsp技术？
+ 核心组件有哪些，都有什么作用？

##### dubbo技术栈

+ 什么是rpc？特点是什么？
+ dubbo的启动过程是怎样的？
+ 如何看待Exchanger、Transporter、Exporter、Protocol等各个核心组件的关系？
+ dubbo如何解析xsd文件？如何实现与Spring进行关联整合？
+ dubbo与SpringCloud的区别？既有dubbo为啥会出现SpringCloud？
+ SPI机制了解吗？dubbo的SPI实现是怎样的，与JDK和Spring的有什么不同？
+ SPI所识别的目录有那些？
+ dubbo协议如何实现的？
+ dubbo服务暴露的原理与过程？

##### Spring技术栈

+ 如何看待和理解IOC和DI？
+ Spring容器的启动、加载过程？
+ Spring Bean实例化及依赖注入的过程，如何解决循环依赖问题？
+ Spring扩展机制？Spring的SPI如何实现的？

##### mybatis技术栈

+ #{}和${}的区别？
  > 虽然这两个都是 mybatis 提供的占位符，看起来时对 mapper 参数进行解析绑定映射处理但又不完全相同，
  > #{} 操作符在对 SQL 语句进行参数填充时采用了预占位符 `?` 的模式，参考 `java.sql.PreparedStatement` 的使用；
  > ${} 操作符对应的参数值，会直接解析进 SQL 语句中，在真正执行 Statement 前就已经完成了参数值填充。常用于对数据库函数传值，分库分表动态表名的传递等场景

+ 缓存机制的理解？

  > 缓存分两类：1）一级缓存，SqlSession级别的本地缓存；2）二级缓存，基于memcached、EHCache等实现，
  > 有点是解决了Session之间的缓存共享问题！

+ mapper加载的过程？
+ 如何实现分页？
+

##### 消息队列技术栈

+ 为什么需要消息队列？它能解决什么问题？

  > 消息队列的具有：__解耦__、__异步__、__削峰__优点：
  > + 解耦：
  > + 异步：
  > + 削峰：
  > 
  > 虽然消息存在那么多好处，它同样也逃不过事物双面性的 “魔咒”，存在这么几个缺点：__系统可用性降低__、__系统复杂度提高__、__一致性问题__！
  
+ 消息重复消费会存在什么问题？如何解决消息幂性？
  > 在使用消息队列对业务进行赋能的时候，必然会出现消息重复消费的问题，稍有不慎就会出现各种问题，例如：支付业务中多扣费、重复写导致的脏数据、积分多次发放等等问题。
  > 这些问题可大可小，一旦出现可能出现 P0 故障，如何避免才是关键！解决的办法其实有很多，例如：通过 redis 进行消息去重、建立消息去重表，通过异步任务扫面任务表处理、
  > 业务消费消息前检查、乐观锁控制等手段都可以避免。

+ RocketMQ为什么快？
  > 采用了零拷贝技术作为消息持久化刷盘的方案，commit-log 采用顺序读取的方式，避免了文件在读写过程中加入读写锁而导致的IO阻塞问题，
  > 同时采用了多主多从的高可用分布式架构，多 broker 部署流量负载分流决定了它可以支撑千万级的消费者

+ Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？
  > 下面简单对比下这四个组件：
  > + __kafka__：吞吐量强可达到千万级，适用于日志、数据计算、批处理等场景，同 topic 下的分区（队列）数量过多（单机超过64）会影响性能，数据分散在各个机器的分区中。
  > 采用主从架构模式，毫秒级的响应时间，消息的并行度与分区（队列）有关
  > + __rocketmq__：吞吐量略低于 kafka， 消息不易丢失，适用于对消息可靠性要求高的场景，例如交易、订单等，同 topic 下的队列数量高于 kafka （单机最高5w），
  > 拥有独立的同步刷盘机制，而 kafka 不支持。采用多主多从的分布式架构，天然就是分布式消息！消息的并行度与消费线程数有关。
  > + __rabbitmq__：消息吞吐量处于百万级，优点是消息时延性可达到微秒级，基于主从做高可用并不是分布式消息队列，单个queue的数据指挥在一个节点中存储，
  > 开启集群模式后，一个queue的数据在各个节点复制都是全量数据。收到消息后暂存在内存中，消费过或过期的消息数据会清理，
  > 这一点不同于 kafka 和 rocketmq 的消息机制，虽然也支持磁盘持久化，但是会降低性能！
  > + __activemq__：很古老了，没有多少人使用了。
  > 
  > 综上所述，目前比较主流的就是 kafka 和 rabbitmq ，互联网大厂都在使用中，采用 kafka 进行数据分析计算、日志收集聚合，
  > 使用 rocketmq 作为业务解耦的消息中间件，消息不会在丢失！

##### xxl-job相关

##### 设计模式

+ 观察者模式
+ 代理模式
+ 访问者模式
+ 状态模式
+ 单例模式
+ 工厂模式

##### netty（会问吗？）

+ Reactor模型有哪些，各有什么特点？
  > reactor模型主要分为三类：
  > + 单线程： acceptor和handler都为单线程，当单个请求处理过慢会导致后续请求被阻塞，导致IO吞吐性能下降。
  > + 多线程：acceptor单线程而handler多线程，解决了单个请求慢而阻塞处理的问题，但是当并发请求量大的时候接受请求的线程就会出现瓶颈。
  > + 主从：acceptor和handler都为多线程执行，可以很好的解决上述出现的两个IO性能问题，一般推荐这种模式

+ InternalThreadLocalMap如何实现的？与ThreadLocalMap有什么不同？
  > InternalThreadLocalMap 是 netty内部扩展实现了一个 threadLocal 模型。

+ 关于BossEventLoopGroup和WorkerEventLoopGroup的理解？
  > 它们的真实面貌就是线程池，不过 Boss 的职责是负责接受分发 Netty IO事件Netty，而 Worker 用于处理数据通道上的IO事件，各司其职又相互配合。
  > Netty 之所以采用两个不同的事件组进行隔离，避免了单一事件组单个IO线程阻塞导致整个服务出现吞吐下降的问题！

+ 对ChannelInboundHandler和ChannelOutboundHandler的理解？

  > 都是继承自ChannelHandler接口，Inbound用于从Channel读取数据，Outbound用于向Channel写数据，各自的职责不同！
  > 当我们需要对服务的输入/输出数据体进行包装、增强、加工时，通过自定义 Handler 并继承 ChannelInboundHandlerAdapter/ChannelOutboundHandlerAdapter 接口即可。
  > Netty 自身也提供了很多很有用的Handler组件供我们直接使用，例如：ByteToMessageCodec、ByteToMessageDecoder、MessageToByteEncoder、ChannelDuplexHandler等。
  > 在 dubbo 的 RPC 数据编解码的过程中，上述 Handler 的身影都有所出现，值得注意的是 ChannelDuplexHandler 是一个双工处理器，可以响应IO出入事件并做出回应！
 

##### 扩展及发散性问题

+ 如何设计一个秒杀功能？
+ 签到功能如何进行实现？
+ 如何设计一个RPC框架？
+ 消息队列如何实现？
+ 怎么看待clickhouse与elasticsearch？
  > 存储结构不同，clickhouse基于列式存储，适用于大量数据计算的场景

+ serverless是什么？
+ 云原生是怎样的？
+ 了解过go吗？
  > 简单的运用过，通过go写过一个客户端程序，并发的性能更好，因为它基于协程实现并发处理

+ jdk8之后都有那些新特性？
  > 支持函数式编程lambda表达式；基于Stream的流式处理；Files/Path工具类的出现；接口默认方法定义

+ RocketMQ事件消息和普通消息有什么不同？
  > 事件消息侧重于已经发生过的每个事件所生出来的消息，它具有具象化、不可变、顺序性等特点。

+ 如何实现一个MQ系统
  > 需要从一下几个方面进行考虑：扩容机制的伸缩性、MQ的可用性（主从架构，舵主多住多从）、如何防止数据丢失（RocketMQ/Kafka的刷盘机制）